<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Domarresan – Bli domarmästare</title>
  <!--
    Den här versionen av Domarresan är anpassad med ett modernt gränssnitt
    inspirerat av Svenska Fotbollförbundets blå/gula färgschema. Den använder
    även Firebase för att synkronisera poäng och framsteg i realtid mellan
    spelare. För att aktivera realtidsfunktionen måste du fylla i ditt
    Firebase-projekts konfigurationsnycklar (apiKey, authDomain, projectId).
  -->
  <style>
    :root {
      /* Färgvariabler: mörkblå, mellanjblå, gul och bakgrundstoner */
      --blue-900: #00295c;
      --blue-700: #0A4E9B;
      --yellow-500: #fdd835;
      --yellow-600: #fbc02d;
      --bg: #0b1b34;
      --card: #ffffff;
      --muted: #e9edf3;
    }

    html, body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: Inter, system-ui, Arial, sans-serif;
      color: #0f172a;
      background:
        radial-gradient(1200px 800px at 20% -10%, #0e3a78 0%, rgba(14, 58, 120, 0) 60%),
        radial-gradient(1000px 600px at 100% 0%, #09305f 0%, rgba(9, 48, 95, 0) 50%),
        var(--bg);
    }

    header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 20px;
      background: linear-gradient(135deg, var(--blue-900), var(--blue-700));
      color: #fff;
    }

    #app-logo {
      height: 42px;
      width: auto;
    }

    #app-title {
      margin: 0;
      font-weight: 800;
      letter-spacing: 0.3px;
    }

    .container {
      max-width: 860px;
      margin: 24px auto;
      padding: 0 16px;
    }

    .card {
      background: var(--card);
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
      padding: 20px;
      margin-bottom: 24px;
    }

    /* Formulär för startskärm */
    #start-screen h2 {
      margin-top: 0;
    }
    #start-screen input {
      width: 100%;
      max-width: 300px;
      padding: 12px 14px;
      font-size: 1rem;
      border-radius: 12px;
      border: 1px solid #ccc;
      margin-bottom: 12px;
    }

    /* Knappar */
    .primary-btn, .ghost-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      font-weight: 700;
      border-radius: 12px;
      padding: 12px 18px;
      border: 0;
      cursor: pointer;
      transition: background 0.2s, border-color 0.2s;
    }
    .primary-btn {
      background: var(--yellow-500);
      color: var(--blue-900);
    }
    .primary-btn:hover {
      background: var(--yellow-600);
    }
    .ghost-btn {
      background: transparent;
      color: #fff;
      border: 2px solid rgba(255, 255, 255, 0.25);
    }
    .ghost-btn:hover {
      border-color: #fff;
    }

    /* Fråga och svar */
    .question {
      font-size: 1.25rem;
      font-weight: 700;
      margin-bottom: 10px;
    }
    .options {
      display: grid;
      gap: 10px;
    }
    .options button {
      text-align: left;
      background: var(--muted);
      border: 0;
      border-radius: 12px;
      padding: 14px 16px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.05s ease, background 0.2s ease;
    }
    .options button:hover {
      background: #dfe6f0;
      transform: translateY(-1px);
    }

    /* Meddelande för rätt/fel svar */
    #message {
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 10px;
      font-weight: 600;
      display: none;
    }

    /* Progress- och tidsstaplar */
    #timer-bar-container,
    #level-progress-container {
      width: 100%;
      background: #e1e5ea;
      border-radius: 999px;
      height: 10px;
      margin-top: 10px;
      overflow: hidden;
    }
    #timer-bar {
      height: 100%;
      width: 0%;
      border-radius: 999px;
      background: linear-gradient(90deg, #ffc107, #ff7043);
    }
    #level-progress {
      height: 100%;
      width: 0%;
      border-radius: 999px;
      background: linear-gradient(90deg, #69c2ff, #165fa5);
    }

    /* Statusraden under frågorna */
    #status {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 12px;
    }
    #status span {
      background: #fff;
      color: var(--blue-900);
      font-weight: 700;
      padding: 8px 12px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }

    /* Leaderboard-styling */
    #leaderboard h2 {
      margin-top: 0;
    }
    .leader-row {
      display: grid;
      grid-template-columns: 56px 1fr auto auto;
      gap: 10px;
      align-items: center;
      padding: 8px 0;
    }
    .rank-badge {
      width: 36px;
      height: 36px;
      display: grid;
      place-items: center;
      border-radius: 999px;
      background: #eef2f7;
      font-weight: 800;
    }
    .rank-1 {
      background: var(--yellow-500);
      color: var(--blue-900);
    }
  </style>
</head>
<body>
  <header>
    <img id="app-logo" src="svff_logo.jpg" alt="SvFF logotyp" />
    <h1 id="app-title">Domarresan – Bli domarmästare</h1>
  </header>
  <div class="container">
    <!-- Startskärm -->
    <div id="start-screen" class="card">
      <h2>Välkommen!</h2>
      <p>Ange ditt namn för att börja din domarresa. Ditt namn kommer att synas i topplistan.</p>
      <input type="text" id="player-name" placeholder="Ditt namn" />
      <div style="margin-top: 12px;">
        <button id="start-button" class="primary-btn">Starta spel</button>
        <button id="show-leaderboard-button" class="ghost-btn">Visa topplista</button>
      </div>
    </div>
    <!-- Spelvyn -->
    <div id="quiz-box" class="card hidden">
      <div class="question" id="question"></div>
      <div class="options" id="options"></div>
      <!-- Meddelande för att visa rätt/fel svar och förklaringar -->
      <div id="message"></div>
      <!-- Visuell timerindikator (ring/stapel) -->
      <div id="timer-bar-container">
        <div id="timer-bar"></div>
      </div>
      <!-- Visuell nivåprogressindikator -->
      <div id="level-progress-container">
        <div id="level-progress"></div>
      </div>
      <div id="status">
        <span id="level"></span>
        <span id="score"></span>
        <span id="streak"></span>
        <span id="timer"></span>
        <span id="progress-text"></span>
      </div>
      <div style="margin-top: 16px;">
        <button id="rescue-button" class="primary-btn" style="display:none; background-color:#e53935; color:#fff;">Räddningsfråga</button>
        <button id="next-button" class="primary-btn" style="display:none;">Nästa fråga</button>
        <button id="show-leaderboard-button-quiz" class="ghost-btn" style="margin-left: 8px;">Visa topplista</button>
      </div>
    </div>
    <!-- Topplistan -->
    <div id="leaderboard" class="card hidden">
      <h2>High Score</h2>
      <div id="leaderboard-entries"></div>
      <div style="margin-top: 16px;">
        <button id="back-button" class="primary-btn">Tillbaka</button>
      </div>
    </div>
  </div>
  <!-- Firebase och spelscript -->
  <script type="module">
    // Importera Firebase-moduler. Dessa hämtas från gstatic CDN.
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getFirestore, doc, setDoc, getDoc, onSnapshot, collection, query, orderBy, limit, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

    /*
      Fyll i dina egna Firebase-konfigurationsuppgifter här. Du hittar dessa
      i din Firebase-konsol under Project settings > General. Om du inte
      vill använda realtidssynkronisering kan du lämna dessa tomma – då
      används endast localStorage och topplistan fungerar enbart på enheten.
    */
    const firebaseConfig = {
      apiKey: "REPLACE_WITH_YOUR_API_KEY",
      authDomain: "REPLACE_WITH_YOUR_AUTH_DOMAIN",
      projectId: "REPLACE_WITH_YOUR_PROJECT_ID",
    };

    // Initiera Firebase endast om apiKey är satt
    let app = null;
    let db = null;
    let auth = null;
    let firebaseUid = null;
    if (firebaseConfig.apiKey && firebaseConfig.projectId) {
      app = initializeApp(firebaseConfig);
      db = getFirestore(app);
      auth = getAuth(app);
      // Logga in anonymt för att få en UID som identifierar användaren i Firestore
      signInAnonymously(auth).then(({ user }) => {
        firebaseUid = user.uid;
      }).catch((error) => {
        console.warn('Kunde inte logga in anonymt i Firebase', error);
      });
    }

    // Speldata: Grundfrågor – samma som i tidigare version
    const baseQuestions = [
      {
        level: 0,
        type: "multiple",
        question: "Varför spelar man i spelformerna 3 mot 3 för de yngsta barnen?",
        options: [
          "För att det ska bli fler spelare på plan",
          "För att varje spelare får fler bollkontakter och enklare spelsituationer",
          "För att använda större plan tidigt",
          "För att kunna göra fler mål direkt på hörna",
        ],
        correct: 1,
        explanation:
          "Mindre plan och färre spelare gör att barnen får fler bollkontakter och enklare spelsituationer.",
      },
      {
        level: 0,
        type: "multiple",
        question:
          "Hur många perioder spelas i en 3‑mot‑3‑match och hur långa är de?",
        options: [
          "2 perioder om 10 minuter",
          "3 perioder om 5 minuter",
          "4 perioder om 3 minuter",
          "1 period om 20 minuter",
        ],
        correct: 2,
        explanation:
          "En 3‑mot‑3‑match består av fyra perioder på cirka 3 minuter vardera.",
      },
      {
        level: 0,
        type: "multiple",
        question: "Får man använda en målvakt i 3‑mot‑3?",
        options: [
          "Ja, en spelare får stå i mål",
          "Nej, alla tre spelare är utespelare",
          "Bara om laget ligger under",
          "Bara om målet är större än 1,6 m",
        ],
        correct: 1,
        explanation:
          "I 3‑mot‑3 finns ingen målvakt – alla spelare är utespelare.",
      },
      {
        level: 0,
        type: "scenario",
        question: "Du dömer en 3v3-match där ett lag ligger under med fyra mål. Vad händer?",
        options: [
          "Inget särskilt, spelet fortsätter",
          "Det ledande laget tar ut en spelare",
          "Det underlägsna laget får sätta in en extra spelare",
          "Matchen avbryts och resultatet står fast",
        ],
        correct: 2,
        explanation:
          "Laget som ligger under med minst fyra mål får spela med en extra spelare tills skillnaden minskar.",
      },
      // 5v5-nivå
      {
        level: 1,
        type: "multiple",
        question:
          "Hur långt ska motspelarna stå från bollen när ditt lag har frispark i 5‑mot‑5?",
        options: ["3 meter", "5 meter", "7 meter", "9 meter"],
        correct: 1,
        explanation:
          "I 5‑mot‑5 ska motståndarna stå minst fem meter från bollen vid frispark.",
      },
      {
        level: 1,
        type: "multiple",
        question: "Får man göra mål direkt på en hörnspark i 5‑mot‑5?",
        options: [
          "Ja, alltid",
          "Nej, bollen måste vidröra en spelare först",
          "Bara om målvakten nuddar bollen",
          "Bara i andra halvlek",
        ],
        correct: 1,
        explanation:
          "I 5‑mot‑5 får man inte göra mål direkt på hörnspark – bollen måste röra en annan spelare först.",
      },
      {
        level: 1,
        type: "multiple",
        question: "Vad gäller vid avspark i 5‑mot‑5?",
        options: [
          "Motståndarna måste stå på egen planhalva och minst tre meter bort",
          "Motståndarna måste stå på egen planhalva och minst fem meter bort",
          "Motståndarna får stå var de vill",
          "Man får inte göra mål direkt på avspark",
        ],
        correct: 1,
        explanation:
          "Vid avspark i 5‑mot‑5 ska alla motståndare vara på egen planhalva och minst fem meter från bollen.",
      },
      {
        level: 1,
        type: "scenario",
        question: "Du dömer en 5v5-match. Var får målvakten använda händerna?",
        options: [
          "I hela sitt straffområde",
          "Inom fem meter från varje mål",
          "Över hela planen",
          "Endast inom målburens längd",
        ],
        correct: 1,
        explanation:
          "Det finns ingen markerad straffzon, men målvakten får använda händerna inom en tänkt 5‑metershalvcirkel från varje målstolpe.",
      },
      // 7v7-nivå
      {
        level: 2,
        type: "multiple",
        question: "Finns offside i 7‑mot‑7?",
        options: [
          "Ja, alltid",
          "Nej, offside tillämpas inte i 7‑mot‑7",
          "Bara på egen planhalva",
          "Bara under hörnor",
        ],
        correct: 1,
        explanation:
          "Offside tillämpas inte i 7‑mot‑7 – regeln införs först i 9‑mot‑9.",
      },
      {
        level: 2,
        type: "multiple",
        question: "Hur långt ska motspelarna stå från bollen vid frispark i 7‑mot‑7?",
        options: ["3 meter", "5 meter", "7 meter", "9 meter"],
        correct: 2,
        explanation:
          "Motståndarna ska stå minst 7 meter från bollen vid frispark i 7‑mot‑7.",
      },
      {
        level: 2,
        type: "scenario",
        question:
          "Du dömer en 7v7-match. Får man göra mål direkt på en inspark (målvaktens utspark)?",
        options: [
          "Ja, direkt mål godkänns",
          "Nej, bollen måste röra en spelare först",
          "Bara om bollen studsar i målgården",
          "Bara om domaren tillåter",
        ],
        correct: 1,
        explanation:
          "I 7‑mot‑7 får man inte göra mål direkt på inspark – bollen måste beröra en annan spelare innan den kan resultera i mål.",
      },
      {
        level: 2,
        type: "multiple",
        question:
          "Hur många spelare (inklusive målvakt) har ett lag på plan i 7‑mot‑7?",
        options: ["5 spelare", "6 spelare", "7 spelare", "8 spelare"],
        correct: 2,
        explanation:
          "Ett lag i 7‑mot‑7 har sex utespelare och en målvakt, totalt sju spelare på planen.",
      },
      // 9v9-nivå
      {
        level: 3,
        type: "multiple",
        question: "Var går gränsen för offside i 9‑mot‑9?",
        options: [
          "Offside tillämpas inte",
          "Spelaren är i offside om någon del av kroppen är på motståndarens planhalva och närmare mållinjen än bollen och näst sista motspelare",
          "Spelaren är i offside bara på egen planhalva",
          "En spelare i offside bedöms aldrig",
        ],
        correct: 1,
        explanation:
          "En spelare är i offsideposition om huvud, kropp eller fötter är på motståndarens planhalva och närmare mållinjen än både bollen och näst sista motspelare och därefter deltar i spelet.",
      },
      {
        level: 3,
        type: "multiple",
        question:
          "Vad är det minsta antalet spelare (inklusive målvakt) som krävs för att en 9‑mot‑9‑match ska fortsätta?",
        options: ["5 spelare", "7 spelare", "8 spelare", "9 spelare"],
        correct: 1,
        explanation:
          "En match kan inte börja eller fortsätta om något av lagen har färre än 7 spelare.",
      },
      {
        level: 3,
        type: "scenario",
        question:
          "Du dömer en 9v9-match. Får man göra mål direkt på ett inkast?",
        options: [
          "Ja",
          "Nej – det blir inspark eller hörna",
          "Bara i första halvlek",
          "Bara om domaren signalerar",
        ],
        correct: 1,
        explanation:
          "Man får inte göra mål direkt på inkast; skulle bollen gå direkt i mål döms inspark eller hörna.",
      },
      {
        level: 3,
        type: "multiple",
        question:
          "Vilken bollstorlek används i 9‑mot‑9 för 13‑åringar och 14‑åringar?",
        options: [
          "Storlek 4 för båda",
          "Storlek 5 för båda",
          "Storlek 4 för 13‑åringar och storlek 5 för 14‑åringar",
          "Storlek 3 för 13‑åringar och storlek 4 för 14‑åringar",
        ],
        correct: 2,
        explanation:
          "I 9‑mot‑9 använder 13‑åringar bollstorlek 4 och 14‑åringar bollstorlek 5.",
      },
      // Avancerat domarkunskap
      {
        level: 4,
        type: "multiple",
        question: "Hur markerar domaren att en frispark är indirekt?",
        options: [
          "Genom att vissla två gånger",
          "Genom att hålla armen upprätt över huvudet",
          "Genom att peka mot mittlinjen",
          "Genom att visa ett gult kort",
        ],
        correct: 1,
        explanation:
          "Domaren markerar indirekt frispark genom att hålla armen upprätt tills bollen har vidrört en annan spelare.",
      },
      {
        level: 4,
        type: "multiple",
        question:
          "Vilka situationer leder till direkt frispark? (Välj det bästa alternativet)",
        options: [
          "Att sparka eller fälla en motspelare, hands, eller hålla fast en spelare",
          "Att ta för lång tid på en inspark",
          "Att protestera mot domaren",
          "Att stå för nära vid frispark",
        ],
        correct: 0,
        explanation:
          "Att sparka, fälla, tackla eller knuffa en motspelare, samt avsiktligt spela bollen med hand/arm, leder till direkt frispark.",
      },
      {
        level: 4,
        type: "scenario",
        question: "När visar domaren rött kort?",
        options: [
          "Vid upprepade regelbrott",
          "Vid farligt spel med överdriven kraft, spottning eller förolämpningar",
          "Om en spelare sparkar bollen över sidlinjen",
          "När domaren bestämmer sig för en paus",
        ],
        correct: 1,
        explanation:
          "Rött kort ges för grovt regelbrott som farligt spel med överdriven kraft, våldsamt beteende, spottning, grova förolämpningar eller om spelaren får två gula kort.",
      },
      {
        level: 4,
        type: "multiple",
        question:
          "Hur ska spelarna och målvakten placeras när en straffspark slås?",
        options: [
          "Alla spelare får stå var som helst",
          "Straffskytten får springa från halva planen och målvakten får röra sig fritt",
          "Skytten ska stå vid straffpunkten, målvakten på mållinjen, övriga spelare utanför straffområdet och minst 9 meter från bollen",
          "Målvakten får stå var som helst i straffområdet",
        ],
        correct: 2,
        explanation:
          "Vid straffspark ska straffskytten stå vid straffpunkten, målvakten ha minst en fot på mållinjen, och övriga spelare stå bakom straffpunkten, utanför straffområdet och minst 9 meter från bollen.",
      },
    ];

    // Generera 1000 frågor genom att replikera grundfrågorna över flera nivåer och typer.
    const questions = [];
    const desiredCount = 1000;
    const totalLevels = 13;
    function randomType(baseType) {
      const rand = Math.random();
      if (rand < 0.15) return "timed";
      if (rand < 0.3) return "scenario";
      return baseType || "multiple";
    }
    while (questions.length < desiredCount) {
      for (const q of baseQuestions) {
        if (questions.length >= desiredCount) break;
        const copy = { ...q };
        copy.level = questions.length % totalLevels;
        copy.type = randomType(q.type);
        if (copy.type === "timed") {
          copy.timeLimit = 10;
        }
        questions.push(copy);
      }
    }

    const levels = [
      "3v3-domare",
      "5v5-domare",
      "7v7-domare",
      "9v9-domare",
      "11v11-domare",
      "Division 2",
      "Division 1",
      "Superettan",
      "Allsvenskan",
      "Premier League",
      "Serie A",
      "Champions League",
      "FIFA VM-final",
    ];

    // Spelstat
    let currentLevel = 0;
    let currentQuestionIndex = 0;
    let currentStreak = 0;
    let score = 0;
    let awaitingRescue = false;
    let playerName = "";
    let timerInterval = null;
    let timeLeft = 0;
    let currentTimeLimit = 0;
    let previousView = "start";
    let leaderboardUnsubscribe = null;

    // Local storage keys
    const progressKeyPrefix = "domarresanProgress_";

    // Hjälpfunktioner för att hämta och spara lokal progress
    function loadProgress(name) {
      const data = localStorage.getItem(progressKeyPrefix + name);
      return data ? JSON.parse(data) : null;
    }
    function saveProgressLocal() {
      if (!playerName) return;
      const progress = {
        currentLevel,
        currentQuestionIndex,
        currentStreak,
        score,
      };
      localStorage.setItem(progressKeyPrefix + playerName, JSON.stringify(progress));
    }

    // Spara progress i Firestore, om Firebase är initierat
    async function saveProgressCloud() {
      if (!db || !firebaseUid) return;
      try {
        // Progress och leaderboard
        await setDoc(
          doc(db, "progress", firebaseUid),
          {
            name: playerName,
            level: currentLevel,
            qIndex: currentQuestionIndex,
            streak: currentStreak,
            score: score,
            updatedAt: serverTimestamp(),
          },
          { merge: true }
        );
        await setDoc(
          doc(db, "leaderboard", "season-1", "entries", firebaseUid),
          {
            name: playerName,
            level: currentLevel,
            score: score,
            updatedAt: serverTimestamp(),
          },
          { merge: true }
        );
      } catch (err) {
        console.warn("Kunde inte spara till Firestore", err);
      }
    }

    // Hämta frågor för aktuellt nivå-index
    function getQuestionsForLevel(level) {
      return questions.filter((q) => q.level === level);
    }

    // HTML-element
    const startScreen = document.getElementById("start-screen");
    const quizBox = document.getElementById("quiz-box");
    const leaderboardDiv = document.getElementById("leaderboard");
    const leaderboardEntries = document.getElementById("leaderboard-entries");
    const questionEl = document.getElementById("question");
    const optionsEl = document.getElementById("options");
    const messageEl = document.getElementById("message");
    const timerBarContainer = document.getElementById("timer-bar-container");
    const timerBar = document.getElementById("timer-bar");
    const levelProgressBar = document.getElementById("level-progress");
    const levelEl = document.getElementById("level");
    const scoreEl = document.getElementById("score");
    const streakEl = document.getElementById("streak");
    const timerEl = document.getElementById("timer");
    const progressTextEl = document.getElementById("progress-text");
    const rescueButton = document.getElementById("rescue-button");
    const nextButton = document.getElementById("next-button");

    // Starta spel för en ny spelare
    function startQuiz(name) {
      playerName = name;
      currentLevel = 0;
      currentQuestionIndex = 0;
      currentStreak = 0;
      score = 0;
      awaitingRescue = false;
      startScreen.classList.add("hidden");
      leaderboardDiv.classList.add("hidden");
      quizBox.classList.remove("hidden");
      updateStatus();
      showQuestion();
    }

    // Visa aktuell fråga
    function showQuestion() {
      const levelQuestions = getQuestionsForLevel(currentLevel);
      if (currentQuestionIndex >= levelQuestions.length) {
        showMessage(
          `Grattis! Du har klarat nivå ${currentLevel + 1}: ${levels[currentLevel]}.`,
          true
        );
        currentLevel++;
        currentQuestionIndex = 0;
        if (currentLevel >= levels.length) {
          finishQuiz();
          return;
        }
        updateStatus();
      }
      const questionObj = getQuestionsForLevel(currentLevel)[currentQuestionIndex];
      questionEl.textContent = questionObj.question;
      optionsEl.innerHTML = "";
      questionObj.options.forEach((opt, index) => {
        const btn = document.createElement("button");
        btn.textContent = opt;
        // Låt CSS-regeln för .options button styra utseendet; endast klickhanterare sätts här.
        btn.addEventListener("click", () => handleAnswer(index));
        optionsEl.appendChild(btn);
      });
      // Dölj extraknappar
      rescueButton.style.display = "none";
      nextButton.style.display = "none";
      // Nollställ timer
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      timerEl.textContent = "";
      timerBar.style.width = "0%";
      timerBarContainer.style.display = "none";
      if (questionObj.type === "timed") {
        currentTimeLimit = questionObj.timeLimit || 10;
        timeLeft = currentTimeLimit;
        timerEl.textContent = `Tid kvar: ${timeLeft}s`;
        timerBarContainer.style.display = "block";
        timerBar.style.width = "100%";
        timerInterval = setInterval(() => {
          timeLeft--;
          timerEl.textContent = `Tid kvar: ${timeLeft}s`;
          const pct = (timeLeft / currentTimeLimit) * 100;
          timerBar.style.width = pct + "%";
          if (timeLeft <= 0) {
            clearInterval(timerInterval);
            timerInterval = null;
            currentStreak = 0;
            awaitingRescue = false;
            showMessage("Tiden tog slut! Du hann inte svara.", false);
            currentQuestionIndex++;
            updateStatus();
            showQuestion();
          }
        }, 1000);
      }
      // Uppdatera nivåprogress-bar
      const progress = (currentQuestionIndex / levelQuestions.length) * 100;
      levelProgressBar.style.width = progress + "%";
    }

    // Hantera svar
    function handleAnswer(selectedIndex) {
      const levelQuestions = getQuestionsForLevel(currentLevel);
      const questionObj = levelQuestions[currentQuestionIndex];
      const correct = selectedIndex === questionObj.correct;
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      if (correct) {
        currentStreak++;
        const streakBonus = currentStreak > 1 ? currentStreak * 10 : 0;
        let timeBonus = 0;
        if (questionObj.type === "timed") {
          timeBonus = timeLeft * 5;
        }
        score += 100 + streakBonus + timeBonus;
        showMessage(
          `Rätt svar! ${(questionObj.explanation || "")}`,
          true
        );
        currentQuestionIndex++;
        updateStatus();
        showQuestion();
      } else {
        if (!awaitingRescue) {
          awaitingRescue = true;
          rescueButton.style.display = "inline-flex";
          rescueButton.onclick = function () {
            presentRescueQuestion();
          };
          showMessage(
            `Fel svar. Rätt svar var "${questionObj.options[questionObj.correct]}". Du har chans till en räddningsfråga för att behålla din streak.`,
            false
          );
        } else {
          currentStreak = 0;
          awaitingRescue = false;
          showMessage(
            `Tyvärr, fel igen. Rätt svar var "${questionObj.options[questionObj.correct]}". Din streak nollställs.`,
            false
          );
          currentQuestionIndex++;
          updateStatus();
          showQuestion();
        }
      }
    }

    // Visa en räddningsfråga
    function presentRescueQuestion() {
      rescueButton.style.display = "none";
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      const levelQuestions = getQuestionsForLevel(currentLevel);
      const randomQuestions = levelQuestions.filter((q, idx) => idx !== currentQuestionIndex);
      const rescueQ = randomQuestions[Math.floor(Math.random() * randomQuestions.length)];
      questionEl.textContent = `Räddningsfråga: ${rescueQ.question}`;
      optionsEl.innerHTML = "";
      rescueQ.options.forEach((opt, idx) => {
        const btn = document.createElement("button");
        btn.textContent = opt;
        btn.addEventListener("click", () => {
          const correct = idx === rescueQ.correct;
          if (correct) {
            showMessage(
              `Bra! Du klarade räddningsfrågan och behåller din streak. ${(rescueQ.explanation || "")}`,
              true
            );
            awaitingRescue = false;
            currentQuestionIndex++;
            updateStatus();
            showQuestion();
          } else {
            showMessage(
              `Fel svar. Rätt svar var "${rescueQ.options[rescueQ.correct]}". Din streak nollställs.`,
              false
            );
            currentStreak = 0;
            awaitingRescue = false;
            currentQuestionIndex++;
            updateStatus();
            showQuestion();
          }
        });
        optionsEl.appendChild(btn);
      });
    }

    // När quizet är klart
    function finishQuiz() {
      quizBox.classList.add("hidden");
      leaderboardDiv.classList.remove("hidden");
      updateStatus();
      showMessage(`Quiz klart! Slutpoäng: ${score}`, true);
      // Synkronisera leaderboard via Firestore om möjligt, annars via localStorage
      if (db && firebaseUid) {
        saveProgressCloud();
      }
      populateLeaderboard();
    }

    // Uppdatera statusraden och spara progress lokalt & i molnet
    function updateStatus() {
      levelEl.textContent = `Nivå: ${levels[currentLevel]}`;
      scoreEl.textContent = `Poäng: ${score}`;
      streakEl.textContent = `Streak: ${currentStreak}`;
      // Progress-text
      const levelQuestions = getQuestionsForLevel(currentLevel);
      if (levelQuestions.length > 0 && currentQuestionIndex < levelQuestions.length) {
        progressTextEl.textContent = `Fråga ${currentQuestionIndex + 1}/${levelQuestions.length}`;
      } else {
        progressTextEl.textContent = "";
      }
      saveProgressLocal();
      if (db && firebaseUid) {
        saveProgressCloud();
      }
    }

    // Visa meddelande på sidan
    function showMessage(text, isCorrect) {
      messageEl.textContent = text;
      messageEl.style.backgroundColor = isCorrect ? "#c8e6c9" : "#ffebee";
      messageEl.style.color = isCorrect ? "#256029" : "#b71c1c";
      messageEl.style.display = "block";
      setTimeout(() => {
        messageEl.style.display = "none";
      }, 3000);
    }

    // Fyll leaderborden med data. Om Firebase används hämtas realtid, annars från localStorage.
    function populateLeaderboard() {
      leaderboardEntries.innerHTML = "";
      if (db && firebaseUid) {
        // Prenumerera på realtidsuppdateringar
        if (leaderboardUnsubscribe) {
          leaderboardUnsubscribe();
        }
        const q = query(collection(db, "leaderboard", "season-1", "entries"), orderBy("score", "desc"), limit(50));
        leaderboardUnsubscribe = onSnapshot(q, (snapshot) => {
          const rows = [];
          snapshot.forEach((docSnap) => {
            rows.push(docSnap.data());
          });
          renderLeaderboard(rows);
        });
      } else {
        // Använd localStorage som fallback
        const scores = JSON.parse(localStorage.getItem("domarresanScores") || "[]");
        scores.sort((a, b) => b.score - a.score || b.level - a.level);
        renderLeaderboard(scores);
      }
    }

    function renderLeaderboard(entries) {
      leaderboardEntries.innerHTML = "";
      entries.forEach((entry, index) => {
        const row = document.createElement("div");
        row.className = "leader-row";
        const badge = document.createElement("div");
        badge.className = "rank-badge" + (index === 0 ? " rank-1" : "");
        badge.textContent = index + 1;
        const nameSpan = document.createElement("div");
        nameSpan.textContent = entry.name || "Anonym";
        const scoreSpan = document.createElement("div");
        scoreSpan.textContent = entry.score;
        const levelSpan = document.createElement("div");
        levelSpan.textContent = levels[entry.level] || levels[0];
        row.appendChild(badge);
        row.appendChild(nameSpan);
        row.appendChild(scoreSpan);
        row.appendChild(levelSpan);
        leaderboardEntries.appendChild(row);
      });
    }

    // Event-lyssnare
    document.getElementById("start-button").addEventListener("click", () => {
      const nameInput = document.getElementById("player-name");
      const name = nameInput.value.trim();
      if (!name) {
        showMessage("Ange ett namn för att börja.", false);
        return;
      }
      const existing = loadProgress(name);
      if (existing) {
        const cont = confirm("Det finns en sparad omgång för detta namn. Vill du fortsätta där du slutade?");
        if (cont) {
          currentLevel = existing.currentLevel;
          currentQuestionIndex = existing.currentQuestionIndex;
          currentStreak = existing.currentStreak;
          score = existing.score;
          playerName = name;
          startScreen.classList.add("hidden");
          quizBox.classList.remove("hidden");
          updateStatus();
          showQuestion();
          return;
        } else {
          localStorage.removeItem(progressKeyPrefix + name);
        }
      }
      startQuiz(name);
    });

    // Topplista-knapp från startskärmen
    document.getElementById("show-leaderboard-button").addEventListener("click", () => {
      // Markera varifrån vi kom
      previousView = "start";
      startScreen.classList.add("hidden");
      quizBox.classList.add("hidden");
      leaderboardDiv.classList.remove("hidden");
      populateLeaderboard();
    });
    // Topplista-knapp inifrån spelvyn
    document.getElementById("show-leaderboard-button-quiz").addEventListener("click", () => {
      previousView = "quiz";
      quizBox.classList.add("hidden");
      leaderboardDiv.classList.remove("hidden");
      populateLeaderboard();
    });
    // Tillbaka-knapp från topplistan
    document.getElementById("back-button").addEventListener("click", () => {
      leaderboardDiv.classList.add("hidden");
      if (previousView === "quiz") {
        quizBox.classList.remove("hidden");
      } else {
        startScreen.classList.remove("hidden");
      }
    });
  </script>
</body>
</html>